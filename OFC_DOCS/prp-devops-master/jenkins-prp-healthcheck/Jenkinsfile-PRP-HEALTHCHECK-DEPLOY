import java.time.LocalDateTime
import groovy.json.JsonBuilder

pipeline {
    agent any

    stages {
        stage('Get User Input') {
            steps {
                echo '*** START GET-USER-INPUT ***'

                script {
                    properties([
                        parameters([
                            extendedChoice(name: 'JOB_NAME', description: '', multiSelectDelimiter: ',', quoteValue: false, saveJSONParameterToFile: false, type: 'PT_HIDDEN', visibleItemCount: 5, defaultBindings: '', defaultGroovyClasspath: '',
                                defaultGroovyScript: '''
                                    def build = Thread.currentThread().toString()
                                    def regexp= ".+?/job/([^/]+)/.*"
                                    def match = build  =~ regexp
                                    def jobName = match[0][1]
                                    return jobName
                                '''
                            ),
                            extendedChoice(name: 'JOB_PROPS', description: '', multiSelectDelimiter: ',', quoteValue: false, saveJSONParameterToFile: false, type: 'PT_HIDDEN', visibleItemCount: 5, defaultBindings: '', defaultGroovyClasspath: '',
                                defaultGroovyScript: '''
                                    def curlCmd = ["curl", "-H \'Accept:application/vnd.github.v3.raw\'", "-o", "jenkins-prp-healthcheck.properties", "-H", "Authorization:token c69d166d536a56ce05bea08aff3be9adfc21c8d5", "https://raw.github.hpe.com/prpdxp/prp-devops/master/jenkins-prp-healthcheck/jenkins-prp-healthcheck.properties"]
                                    def proc = curlCmd.execute()
                                    proc.waitFor()
                                    Properties properties = new Properties()
                                    File propertiesFile = new File("jenkins-prp-healthcheck.properties")
                                    def stream = propertiesFile.newDataInputStream()
                                    properties.load(stream)
                                    def groovyPropMap = []
                                    properties.each() { k, v -> groovyPropMap << \'"\' + k + \'":"\' + v + \'"\'}
                                    return groovyPropMap.toString()
                                '''
                            ),
                            [$class: 'CascadeChoiceParameter', name: 'DEPLOY_ENVIRONMENT', choiceType: 'PT_SINGLE_SELECT', description: '', filterLength: 1, filterable: false, randomName: 'choice-parameter-5012569915603583', referencedParameters: 'JOB_NAME,JOB_PROPS', script: [$class: 'GroovyScript', fallbackScript: [classpath: [], sandbox: false, script: ''], script: [classpath: [], sandbox: false,
                                script: '''
				                    if (!JOB_NAME.contains("NON-PROD")) {
                                        return Arrays.asList(Eval.me(JOB_PROPS)['DEPLOY_ENV_LIST.PRD'].split(","))
                                    } else {
                                        return Arrays.asList(Eval.me(JOB_PROPS)['DEPLOY_ENV_LIST.NON_PRD'].split(","))   
                                    }
                                '''
                            ]]],
			    extendedChoice(defaultValue: 'PRP-HEALTHCHECK-BUILD', description: '', multiSelectDelimiter: ',', name: 'JENKINS_BUILD_JOB', quoteValue: false, saveJSONParameterToFile: false, type: 'PT_HIDDEN', value: 'PRP-HEALTHCHECK-BUILD', visibleItemCount: 5),
                            //string(name: 'JENKINS_BUILD_JOB', defaultValue: 'PRP-HEALTHCHECK-BUILD', description: '', trim: false),
                            [$class: 'CascadeChoiceParameter', name: 'JENKINS_BUILD_NUM', choiceType: 'PT_SINGLE_SELECT', description: '', filterLength: 1, filterable: false, randomName: 'choice-parameter-5011039524967777', referencedParameters: 'JOB_PROPS,JENKINS_BUILD_JOB', script: [$class: 'GroovyScript', fallbackScript: [classpath: [], sandbox: false, script: ''], script: [classpath: [], sandbox: false,
                                script: '''
                                    def jenkinsBuildList = "ls -vm ${Eval.me(JOB_PROPS).JENKINS_HOME}/jobs/${JENKINS_BUILD_JOB}/builds/".execute().text.trim()
                                    return Arrays.asList(jenkinsBuildList.split(","))
                                '''
                            ]]],
                            [$class: 'DynamicReferenceParameter', choiceType: 'ET_FORMATTED_HTML', description: '', name: 'BUILD_DESCRIPTION', omitValueField: false, randomName: 'choice-parameter-4317506565630469', referencedParameters: 'JOB_PROPS,JENKINS_BUILD_JOB,JENKINS_BUILD_NUM', script: [$class: 'GroovyScript', fallbackScript: [classpath: [], sandbox: false, script: ''], script: [classpath: [], sandbox: false,
                                script: '''
                                    import groovy.json.JsonSlurper
                                    File file = new File("${Eval.me(JOB_PROPS).JENKINS_HOME}/jobs/${JENKINS_BUILD_JOB}/builds/${JENKINS_BUILD_NUM.trim()}/build-info.json")
                                    
                                    if (file.exists()) {
                                      def InputJSON = new JsonSlurper().parseText(file.text)
                                      output = "<tr><th>Job Name</th><th>Job Type</th><th>Peformed By</th><th>Occurred On</th><th>Artifact Count</th><th>Env</th><th>Comment</th></tr>"
                                      output = output + "<tr><td>${JENKINS_BUILD_JOB} #${JENKINS_BUILD_NUM.trim()} (${InputJSON.env})</td><td>${InputJSON.action}</td><td>${InputJSON.performedBy}</td><td>${InputJSON.performedAt}</td><td>${InputJSON.artifactCount}</td><td>${InputJSON.env}</td><td>${InputJSON.comment}</td></tr>"
                                      return "<style>.bordered-table {border: 1px solid black; border-collapse: collapse; margin-top: 1em; margin-bottom: 1em} .bordered-table th {border: 1px solid black;} .bordered-table td {border: 1px solid black;} </style><table class=\\"bordered-table\\">" + output + "</table>"
                                    } else {
                                      output = "${JENKINS_BUILD_JOB} #${JENKINS_BUILD_NUM.trim()} ("
                                      def dateCmd = ["date", "-r", "${Eval.me(JOB_PROPS).JENKINS_HOME}/jobs/${JENKINS_BUILD_JOB}/builds/${JENKINS_BUILD_NUM.trim()}/archive/jenkins-build-output/", "+%F %T %z"]
                                      def artifactCountCmd = "ls ${Eval.me(JOB_PROPS).JENKINS_HOME}/jobs/${JENKINS_BUILD_JOB}/builds/${JENKINS_BUILD_NUM.trim()}/archive/jenkins-build-output/ | wc -l"
                                      output = output + dateCmd.execute().text.trim()
                                      def artifactCount = ["bash", "-c", artifactCountCmd].execute().text.trim()
                                      output = output + ") contains " + artifactCount
                                      output = output + " artifacts."
                                      return "<i>"+output+"</i>"
                                    }  
                            '''
                            ]]],
                            [$class: 'CascadeChoiceParameter', name: 'BUILD_MODULE_LIST', choiceType: 'PT_MULTI_SELECT', description: '', filterLength: 1, filterable: false, randomName: 'choice-parameter-3049196836771549', referencedParameters: 'JOB_PROPS,JENKINS_BUILD_JOB,JENKINS_BUILD_NUM', script: [$class: 'GroovyScript', fallbackScript: [classpath: [], sandbox: false, script: ''], script: [classpath: [], sandbox: false,
                                script: '''
                                    def myList = []
                                    def dir = new File("${Eval.me(JOB_PROPS).JENKINS_HOME}/jobs/${JENKINS_BUILD_JOB}/builds/${JENKINS_BUILD_NUM.trim()}/archive/build/libs")
                                    dir.eachFile { myFile ->
                                        myList << myFile.getName()
                                    }
                                    return myList
                                '''
                            ]]],
							//extendedChoice(name: 'TAKE_BACKUP', description: '', multiSelectDelimiter: ',', quoteValue: false, saveJSONParameterToFile: false, type: 'PT_RADIO', defaultValue: 'NO', value: 'NO,YES', visibleItemCount: 5),
                            //booleanParam(defaultValue: false, description: '', name: 'TAKE_BACKUP'),
                            [$class: 'DynamicReferenceParameter', choiceType: 'ET_FORMATTED_HTML', description: '', name: 'TAKE_BACKUP', omitValueField: true, defaultValue: 'NO', randomName: 'choice-parameter-2003150150145', script: [$class: 'GroovyScript', fallbackScript: [classpath: [], sandbox: false, script: ''], script: [classpath: [], sandbox: false,
                                script: '''
                                    return "<div><input name=\\"value\\" type=\\"radio\\" value=\\"YES\\"> YES</div><div><input name=\\"value\\" type=\\"radio\\" value=\\"NO\\"> NO</div>"
								'''		
                            ]]],
							[$class: 'DynamicReferenceParameter', choiceType: 'ET_FORMATTED_HTML', description: '', name: 'TAKE_BACKUP_COMMENT', omitValueField: true, randomName: 'choice-parameter-200315015014515', referencedParameters: 'TAKE_BACKUP', script: [$class: 'GroovyScript', fallbackScript: [classpath: [], sandbox: false, script: ''], script: [classpath: [], sandbox: false,
                                script: '''
                                    if (!TAKE_BACKUP.equals("YES")) {
                                        return "<b>No Backup</b><input type=\\"hidden\\" name=\\"value\\" value=\\"No Backup\\" />"
                                    }
                                    
                                    return "<textarea name=\\"value\\" style=\\"margin: 0px; height: 155px; width: 450px;\\"></textarea>"
								'''
                            ]]]
                        ])
                    ])
                }

                echo '*** END GET-USER-INPUT ***'
            }
        }
		stage('Take Backup') {
            when {
                expression {
                    return params.TAKE_BACKUP == "YES" && params.TAKE_BACKUP_FROM.contains("liferay")
                }
            }
            steps {
                echo '*** START TAKE-BACKUP ***'

                script {                    
					def lrNode
                    def nodeLoc
                    def nodeServerIp
                    def nodeDir
                    def lrNodeList
					
					def dxpPrpProps = Eval.me(params.JOB_PROPS)
					
					lrNode = params.TAKE_BACKUP_FROM
					
					nodeLoc = dxpPrpProps["NODE_LOC." + params.DEPLOY_ENVIRONMENT + "." + lrNode]
					nodeLoc = nodeLoc.split("\\|")

                    echo "nodeLoc --> ${nodeLoc}"
					
					nodeServerIp = nodeLoc[0]
                    nodeDir = nodeLoc[1]
					
					echo "nodeServerIp --> ${nodeServerIp}"
                    echo "nodeDir --> ${nodeDir}"
					
					def artifacts = params.BUILD_MODULE_LIST
					
					// modules (*.jar files)
					def scpCmd = artifacts.contains(",") ? "scp liferay@${nodeServerIp}:${nodeDir}/osgi/modules/\\{${artifacts}\\} ./" : "scp liferay@${nodeServerIp}:${nodeDir}/osgi/modules/${artifacts} ./"
					
					// wars (*.war files)
					scpCmd += "\n" + (artifacts.contains(",") ? "scp liferay@${nodeServerIp}:${nodeDir}/osgi/war/\\{${artifacts}\\} ./" : "scp liferay@${nodeServerIp}:${nodeDir}/osgi/war/${artifacts} ./")
					
					def nextBackupBuildNumber = sh (
						script: "cd ${env.JENKINS_HOME}/jobs/DXP-BACKUP/builds/ && ls | sort -n | tail -n1",
						returnStdout: true
					).trim()
					
					if (nextBackupBuildNumber.isEmpty()) {
						nextBackupBuildNumber = 1
					} else {
						nextBackupBuildNumber = Integer.parseInt(nextBackupBuildNumber) + 1
					}
					
					echo '''#!/bin/bash
							cd ''' + env.JENKINS_HOME + '''/jobs/DXP-BACKUP/builds/
							mkdir ''' + nextBackupBuildNumber + ''' ''' + nextBackupBuildNumber + '''/archive ''' + nextBackupBuildNumber + '''/archive/jenkins-build-output
							cd ''' + nextBackupBuildNumber + '''/archive/jenkins-build-output
							''' + scpCmd + '''
						'''
					
					try {
						sh '''#!/bin/bash
							cd ''' + env.JENKINS_HOME + '''/jobs/DXP-BACKUP/builds/
							mkdir ''' + nextBackupBuildNumber + ''' ''' + nextBackupBuildNumber + '''/archive ''' + nextBackupBuildNumber + '''/archive/jenkins-build-output
							cd ''' + nextBackupBuildNumber + '''/archive/jenkins-build-output
							''' + scpCmd + '''
						'''
					} catch (err) {
						echo err.getMessage()
					}
					
					def backupArtifactList = sh(script: "find ${env.JENKINS_HOME}/jobs/DXP-BACKUP/builds/${nextBackupBuildNumber}/archive/jenkins-build-output -type f -printf '%f\\n' 2>/dev/null || true", returnStdout: true).split()
                    echo "backupArtifactList --> ${backupArtifactList}"
                    def backupArtifactCount = backupArtifactList.size()
                    echo "backupArtifactCount --> ${backupArtifactCount}"
					
					BUILD_TRIGGER_BY = "${currentBuild.getBuildCauses()[0].userId}"
					echo "BUILD_TRIGGER_BY: ${BUILD_TRIGGER_BY}"
					
					// prepare json
					def builder = new JsonBuilder()
					builder performedBy: BUILD_TRIGGER_BY, performedAt: LocalDateTime.now().toString(), artifactCount: backupArtifactCount, artifactList: backupArtifactList, action: 'BACKUP', env: params.DEPLOY_ENVIRONMENT, nodeList: [params.TAKE_BACKUP_FROM], comment: params.TAKE_BACKUP_COMMENT
					json = builder.toPrettyString()

					// print to console and write to a file
					println json
					new File(env.JENKINS_HOME + "/jobs/DXP-BACKUP/builds/" + nextBackupBuildNumber + "/build-info.json").write(json)

                }

                echo '*** END TAKE-BACKUP ***'
            }
        }
        stage('Deploy') {
            when {
                expression {
                    return params.DEPLOY_ENVIRONMENT && params.BUILD_MODULE_LIST
                }
            }
            steps {
                echo '*** START DEPLOY ***'

                script {

                    def dxpPrpProps = Eval.me(params.JOB_PROPS)
                    def buildJobName = params.JENKINS_BUILD_JOB
                    def artifacts = params.BUILD_MODULE_LIST.replaceAll(",", " ")

                    def appLoc = dxpPrpProps["APP_LOC.PRP_HEALTHCHECK." + params.DEPLOY_ENVIRONMENT]

                    appLoc = appLoc.split("~")
                    echo "appLoc --> ${appLoc}"

                    def appServerIp = appLoc[1]
                    def appDir = appLoc[2]
                    echo "appServerIp --> ${appServerIp}"
                    echo "appDir --> ${appDir}"

                    sh "cd ${env.JENKINS_HOME}/jobs/${buildJobName}/builds/${params.JENKINS_BUILD_NUM.trim()}/archive/build/libs && chmod 755 * && scp ${artifacts} prp-healthcheck@${appServerIp}:${appDir}"

                    sh """
                        #!/bin/bash
                        ssh prp-healthcheck@${appServerIp} << EOF
                            sudo service prp-healthcheck restart
                            exit 0
                        << EOF
                    """

                    // construct build-info.json
                    echo "JOB_NAME --> ${env.JOB_NAME}"
                    echo "BUILD_NUMBER --> ${currentBuild.number}"
                    
                    def artifactCount =  params.BUILD_MODULE_LIST.split(",").size()
                        
					BUILD_TRIGGER_BY = "${currentBuild.getBuildCauses()[0].userId}"
					echo "BUILD_TRIGGER_BY: ${BUILD_TRIGGER_BY}"
					
					def jenkins = Jenkins.getInstance()
					
					def FULL_PROJECT_NAME = currentBuild.getFullProjectName()
					echo "FULL_PROJECT_NAME --> ${FULL_PROJECT_NAME}"
					
					JOB_BUILD_DIR = jenkins.getItemByFullName(FULL_PROJECT_NAME).getBuildDir()
					
					// prepare json
					def builder = new JsonBuilder()
					builder performedBy: BUILD_TRIGGER_BY, performedAt: LocalDateTime.now().toString(), artifactCount: artifactCount, artifactList: params.BUILD_MODULE_LIST.split(","), action: 'DEPLOY', env: params.DEPLOY_ENVIRONMENT, nodeList: '', comment: ''
					json = builder.toPrettyString()

					// print to console and write to a file
					println json
					new File(JOB_BUILD_DIR.toString() + "/" + currentBuild.number + "/build-info.json").write(json)
                }

                echo '*** END DEPLOY ***'
            }
        }
    }
}
