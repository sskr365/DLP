pipeline {
	agent any
	stages {
        stage('Input Parameters') {
            steps {
                script {
                    properties([
						parameters([
                            extendedChoice(defaultValue: 'prpdxp/prpws', description: 'Enter HPE Git repository, format: ${username}/${repo-name} (e.g. prpdxp/prpws)', multiSelectDelimiter: ',', name: 'GIT_HPE_REPO', quoteValue: false, saveJSONParameterToFile: false, type: 'PT_TEXTBOX', visibleItemCount: 5),
                            [$class: 'CascadeChoiceParameter', choiceType: 'PT_SINGLE_SELECT', description: '', filterLength: 1, filterable: false, name: 'GIT_HPE_BRANCH', randomName: 'choice-parameter-4816978971651983', referencedParameters: 'GIT_HPE_REPO', script: [$class: 'GroovyScript', fallbackScript: [classpath: [], sandbox: false, script: ''], script: [classpath: [], sandbox: false,
                                script: '''
                                    def gitURL = "git@github.hpe.com:${GIT_HPE_REPO}.git"
                                    def command = "git ls-remote -h $gitURL"
                                    def proc = command.execute()
                                    proc.waitFor()
                                    if ( proc.exitValue() != 0 ) {
										println "Error, ${proc.err.text}"
										return
                                    }
                                    def branches = proc.in.text.readLines().collect {
                                        it.replaceAll(/[a-z0-9]*\\trefs\\/heads\\//, \'\')
                                    }
                                    return branches
                                '''
                            ]]],
                            extendedChoice(name: 'JOB_NAME', description: '', multiSelectDelimiter: ',', quoteValue: false, saveJSONParameterToFile: false, type: 'PT_HIDDEN', visibleItemCount: 5, defaultBindings: '', defaultGroovyClasspath: '',
                                defaultGroovyScript: '''
                                    def build = Thread.currentThread().toString()
                                    def regexp= ".+?/job/([^/]+)/.*"
                                    def match = build  =~ regexp
                                    def jobName = match[0][1]
                                    return jobName
                                '''
                            ),
                            [$class: 'CascadeChoiceParameter', choiceType: 'PT_MULTI_SELECT', description: '', filterLength: 1, filterable: false, name: 'EXTERNAL_JAR_LIST', randomName: 'choice-parameter-2913799236623041', referencedParameters: 'GIT_HPE_REPO,GIT_HPE_BRANCH', script: [$class: 'GroovyScript', fallbackScript: [classpath: [], sandbox: false, script: ''], script: [classpath: [], sandbox: false, 
                            script: 
                                '''
                                    def readAccessToken = "c69d166d536a56ce05bea08aff3be9adfc21c8d5"
                                    def curlCmd = ["curl", "-H", "Accept: application/vnd.github.v3+json", "-H", "Authorization: token ${readAccessToken}", "https://github.hpe.com/api/v3/repos/${GIT_HPE_REPO}/contents/external-jars?ref=${GIT_HPE_BRANCH}"]
                                    def proc = curlCmd.execute().text
                                    def json = new groovy.json.JsonSlurper().parseText(proc)
                                    def jarList = json.name
                                    for(jars in jarList) {
                                        if(!jars.contains("jar")) {
                                            jarList.remove(jars)
                                        }
                                    }
                                    return jarList
                                '''
                            ]]],
                            extendedChoice(name: 'JOB_PROPS', description: '', multiSelectDelimiter: ',', quoteValue: false, saveJSONParameterToFile: false, type: 'PT_HIDDEN', visibleItemCount: 5, defaultBindings: '', defaultGroovyClasspath: '',
                                defaultGroovyScript: '''
                                    def curlCmd = ["curl", "-H \'Accept:application/vnd.github.v3.raw\'", "-o", "jenkins-dxp-prp.properties", "-H", "Authorization:token c69d166d536a56ce05bea08aff3be9adfc21c8d5", "https://raw.github.hpe.com/prpdxp/prp-devops/master/jenkins-dxp/jenkins-dxp-prp.properties"]
                                    def proc = curlCmd.execute()
                                    proc.waitFor()
                                    Properties properties = new Properties()
                                    File propertiesFile = new File("jenkins-dxp-prp.properties")
                                    def stream = propertiesFile.newDataInputStream()
                                    properties.load(stream)
                                    def groovyPropMap = []
                                    properties.each() { k, v -> groovyPropMap << \'"\' + k + \'":"\' + v + \'"\'}
                                    return groovyPropMap.toString()
                                '''
                            ),
                            [$class: 'CascadeChoiceParameter', name: 'DEPLOY_ENVIRONMENT', choiceType: 'PT_SINGLE_SELECT', description: '', filterLength: 1, filterable: false, randomName: 'choice-parameter-5012569915603583', referencedParameters: 'JOB_NAME,JOB_PROPS', script: [$class: 'GroovyScript', fallbackScript: [classpath: [], sandbox: false, script: ''], script: [classpath: [], sandbox: false,
                                script: '''
									if (JOB_NAME.contains("NON-PROD")) {
                                        return Arrays.asList(Eval.me(JOB_PROPS).env_list.split(","))
                                    } else {
                                        return Arrays.asList(Eval.me(JOB_PROPS).env_list_prd.split(","))   
                                    }
                                '''
                            ]]],
							[$class: 'CascadeChoiceParameter', name: 'LR_NODES', choiceType: 'PT_CHECKBOX', description: '', filterLength: 1, filterable: false, randomName: 'choice-parameter-3049196836771548', referencedParameters: 'JOB_PROPS,DEPLOY_ENVIRONMENT', script: [$class: 'GroovyScript', fallbackScript: [classpath: [], sandbox: false, script: ''], script: [classpath: [], sandbox: false,
                                script: '''
                                    return Arrays.asList(Eval.me(JOB_PROPS)["NODE_LIST." + DEPLOY_ENVIRONMENT].split(","))
                                '''
                            ]]],
							extendedChoice(name: 'TOMCAT_RESTART_OPTION', description: '', multiSelectDelimiter: ',', quoteValue: false, saveJSONParameterToFile: false, type: 'PT_RADIO', defaultValue: 'NO RESTART', value: 'NO RESTART,NORMAL RESTART,CLEAN RESTART', visibleItemCount: 5)
						])
					])
                }
            }
        }
	    stage('Checkout SCM : External Jar Deploy') {
	        steps {
                script {
                    sh 'mkdir -p prp-external-jar'
                    sh 'chmod 755 prp-external-jar'
                    dir('prp-external-jar') {
                        git url : 'git@github.hpe.com:${GIT_HPE_REPO}.git' , branch : params.GIT_HPE_BRANCH
                    }
                }
            }
	    }
		stage('External Jar Deploy') {
			steps {
				script {
                    def lrNode
                    def lrNodesList = []
                    def nodeServerIp
                    def nodeLoc
                    def nodeDir
                    def nodeName
                    def jarList

                    lrNodeList = Arrays.asList(params.LR_NODES.split(","))

					dir('prp-external-jar/external-jars') {
						echo "Deploying external jar"
                        def jobProps = Eval.me(params.JOB_PROPS)
                        def jars = sh(returnStdout: true, script: 'ls ${WORKSPACE}/prp-external-jar/external-jars | grep jar')
                        
                        for (int i = 0; i < lrNodeList.size(); i++) {
                            lrNode = lrNodeList.get(i)
                            nodeName = jobProps["NODE_LOC."+params.DEPLOY_ENVIRONMENT+"."+lrNode]
                            nodeName = nodeName.split("\\|")
                            nodeServerIp = nodeName[0]
                            nodeDir = nodeName[1]
                            echo "Deploy env : ${params.DEPLOY_ENVIRONMENT}"
                            echo "Node server IP : ${nodeServerIp}"
                            echo "Node dir : ${nodeDir}"
                            echo "Jars : ${jars}"
                            jarList = params.EXTERNAL_JAR_LIST.replaceAll(","," ")
                            sh "scp ${jarList} liferay@${nodeServerIp}:${nodeDir}/deploy"
                        }
					}
				}
			}
		}
        stage('Tomcat Restart') {
            when {
                expression {
                    return params.TOMCAT_RESTART_OPTION == "NORMAL RESTART" || params.TOMCAT_RESTART_OPTION == "CLEAN RESTART"
                }
            }
            steps {
                script {
                    def lrNode
                    def lrNodesList = []
                    def nodeServerIp                 
                    def nodeDir
                    def nodeName

                    for (int i = 0; i < lrNodeList.size(); i++) {
                        lrNode = lrNodeList.get(i)
                        nodeName = jobProps["NODE_LOC."+params.DEPLOY_ENVIRONMENT+"."+lrNode]
                        nodeName = nodeName.split("\\|")
                        nodeServerIp = nodeName[0]
                        nodeDir = nodeName[1]
                        if(params.TOMCAT_RESTART_OPTION == "CLEAN RESTART") {
                            echo "Starting up liferay node after artifact deployment. nodeServerIp --> ${nodeServerIp}, nodeDir --> ${nodeDir}"
                            sh ". ~/liferay-normal-restart.sh ${nodeServerIp} ${nodeDir}"
                        } else if(params.TOMCAT_RESTART_OPTION == "NORMAL RESTART") {
                            echo "Triggering normal restart for liferay nodeServerIp --> ${nodeServerIp}, nodeDir --> ${nodeDir}"
                            sh ". ~/liferay-normal-restart.sh ${nodeServerIp} ${nodeDir}"
                        }
                    }
                }
            }
        }
	}
    post {
        always {
            cleanWs()
        }
    }
}